---
layout: post
title: "Git Coin Project Maintainer Consensus Protocol"
date: 2017-10-20 -0800 4:17 PM PDT
comments: true
categories: [git crypto humor]
---

A [recent wry tweet](https://twitter.com/bcrypt/status/918222753500508160) by [@bcrypt](https://twitter.com/bcrypt/) really tickled my funny bone:

> gitcoin: the author of the commit sha1 with the longest prefix of 0's in your repository is now the project maintainer

The genius in the tweet is the way it associates the SHAs used in the Bitcoin proof of work consensus protocol with Git commit SHAs as a means of choosing a project maintainer.

Is this a good way to pick a project maintainer? Probably not. But I bet there are some of you who are thinking, why not give it a try? I've got just the command for you. Just run the following command in a Git repository and it'll return the name of the author, the commit date, and the SHA of the commit that has the lowest SHA sorted lexicographically.

```
git log --pretty=format:"%H %ad %an" | sort | head -n1
```

Or, if you prefer a Git alias:

```
[alias]
  coin = !git log --pretty=format:'%H %ad %an' | sort | head -n1
```

The way this works is pretty simple. We use the `--pretty=format` option to provide `git log` a custom format string so we can control the output. The `%H` displays the commit SHA. `%ad` is the commit date and `%an` is the author name. We pipe that to `sort`. Since no two SHAs can be the same, we don't have to worry about sorting on the first column. It's all the same. Then we use `head -n1` to pluck the first item.

It's possible that there won't be any commits with leading 0s, but I ignore that for now. I figure the commit with the lowest SHA sorted alphabetically fits with the spirit of the idea.

Since github.com runs on Ruby on Rails, I thought it'd be fur to try it out on https://github.com/rails/rails. I cloned the repository to my machine and ran `git coin` on it. Here's the output:

> 000121e87e4e0a3912a2f5d4edfff7bbeb71078f Thu Nov 15 23:10:45 2012 +0200 Agis Anastasopoulos

Congratulations Agis! You are the new maintainer of Rails!

## Wait a minute!

I know what some of you are thinking, "You are ridiculous. This is a waste of time." To those I say, hold my beer because I'm not done yet.

I know that others of you who are familiar with Bitcoin's consensus protocol are thinking, "This is not how the protocol works. It's about reaching a target number of leading zeros, not choosing the lowest sorted SHA." To those I say, you're not seriously thinking of using this to choose a maintainer, are you?! Because I'm not serious here.

However, in anticipation of all the "Well, Actually" responses, I'll address this fair point. With Bitcoin, the first miner (hand waving a bit here) to generate a SHA with the target number of leading zeros gets to add their block to the blockchain. It's not the block with the lowest SHA. Over time, the protocol compensates for the global increase in computing power by increasing the number of leading zeros in the target. That way a block is added roughly every ten minutes no matter how fast computers get and no matter how many computers are working on it.

Translating this to gitcoin, rather than sorting SHAs and looking for the one with the most zeros, we may want to look at the first commit to reach the most number of zeros.

For example, say that the current maintainer was chosen because of a commit with a SHA that has two leading zeros. The next maintainer is one who has a commit with three leading zeroes. The next one after that is the first commit with four leading zeroes. In other words, every time a new maintainer is chosen by this protocol, the target increases by one.

The shell script to find the maintainer with these rules is considerably more complex. My background is primarily with Windows so my Unix-fu is fairly weak. However, my time at GitHub working with Git has helped me exercise those muscles quite a bit more than I did previously. Here's the script I came up with:

> TZ=UTC git log --pretty=format:'%H%x09%ad%x09%an' --date=iso-local | grep ^0.* | sed -E 's/(0+)(.*)/\1\t\1\2/' | sort -k1,1 -k3,3r | tail -n1 | cut -f 2,3,4

## The breakdown

Let's break this down piece by piece for those of you like me who don't eat and breath shell scripting.

The first thing we do is set the local timezone to UTC so we can sort by date and compare apples to apples.

`git log --pretty=format:'%H%x09%ad%x09%an' --date=iso-local`

Just like before, we're running a git log command. It looks ugly, but all I'm doing here is using tab character `%x09` in place of spaces. That'll come
in handy later. I also specify that the date format should be `iso-local`. This provides a date that's sortable lexicographically. We'll need that later too.

`grep ^0.*`

I then pipe all these results to `grep` with a very simple regex. We're only looking at commit SHAs that start with at least one `0`.

`sed -E 's/(0+)(.*)/\1\t\1\2/' `

Sed is a powerful command used to perform text transformations on an input stream. In this case, we're using the `s/` command which is a regex replacement. The `-E` indicates that sed should use extended regular expressions. What I'm doing here is extracting the consecutive sequence of `0`s that the SHA starts with as a new column in the output.

So if the `git log` command we ran earlier returned something like:

```
005371e16cf214509bb988dcf5d0eef3ee23157d	2004-12-01 13:59:16 +0000	David Heinemeier Hansson
0daa29ece29191b288fe86d3616bea0357325419	2004-12-01 13:18:51 +0000	David Heinemeier Hansson
08a2249e907eabe087b6a4a32f1892d4e58b7b82	2004-11-26 02:16:05 +0000	David Heinemeier Hansson
```

Piping it to this sed expression would return:

```
00	005371e16cf214509bb988dcf5d0eef3ee23157d	2004-12-01 13:59:16 +0000	David Heinemeier Hansson
0	0daa29ece29191b288fe86d3616bea0357325419	2004-12-01 13:18:51 +0000	David Heinemeier Hansson
0	08a2249e907eabe087b6a4a32f1892d4e58b7b82	2004-11-26 02:16:05 +0000	David Heinemeier Hansson
```

That format is pretty handy because we can sort this by the first column which is the number of zeroes a SHA has as its prefix. That'll group all SHAs with the same number of leading zeroes together. Then we can do a reverse sort by the date column to find the first commit in any such group.

`sort -k1,1 -k3,3r`

Does exactly that. One thing that tripped me up when I first worked on this is I thought I should be able to `sort -k1 -k3r`. The `-k` option specifies a sort key. By default, when you specify a column, it takes that column and all columns after it as the sort key. Thus `-k1` is pretty much equivalent to not specifying a sort key at all as it sorts by the whole line.

Fortunately, you can specify an end column for the sort key using the comma. So `-k1,1` sorts just by the first column. Whereas `-k1,3` would take the first three columns as a sort key.

`tail -n1`

Now that we have the proper sort in play, we just need to take the last entry. That'll be the oldest commit with the most leading zeroes.

`cut -f 2,3,4`

And finally, we don't need the leading zeroes column in the final output so I run the `cut` command and only keep columns 2, 3, and 4.

## In Conclusion

When I run this against the Rails repository, it outputs:

> 00050dfedb8976741dbe998e4abc2281fa855c76	2006-04-09 21:27:32 +0000	David Heinemeier Hansson

Sorry Agis, David Heinemeier Hansson is now the Rails maintainer. Whoever you are, I hope you take this responsibility seriously Mr. Hansson.
